## 你提到的点是必须的：场景入口 vars 快照
- 既然我们“先进入目标场景再开始重放”，那么重放的初始条件必须等价于“进入该场景瞬间”的状态。
- 如果循环/分支依赖 `state.vars`（见 [EngineState.vars](file:///d:/Projcets/KosuzuEngine/src/engine/core/EngineContext.ts#L34-L95)），那就必须在场景开始时保存一份 vars 快照，否则从空 vars 重放会走错分支/死循环。

## 目标（阶段1）
- full：从目标场景入口开始重放到目标帧，过程中允许可观察效果；到目标帧停在对话等待。
- fast：重放语义与 full 等价，但到目标帧前不产生可观察副作用；到目标帧一次性提交并停下。
- 两者都依赖：
  - `choiceTrail`（仅当前场景的选择轨迹）
  - `entryVars`（进入当前场景瞬间的 vars 快照）

## 实施步骤
### 1) 统一存档读取路径（修复 IndexedDB/localStorage 不一致）
- 复用现有 [Runtime.load](file:///d:/Projcets/KosuzuEngine/src/engine/core/Runtime.ts#L636-L670) 的后端选择逻辑。
- 修改 [engine-store.load](file:///d:/Projcets/KosuzuEngine/src/stores/engine-store.ts#L170-L245) 不再直接读 `localStorage['save:'+slot]`，改走 Runtime（必要时新增一个只读 `getSaveData(slot)` 用于拿到 meta/entryVars/choices 决策）。

### 2) 在“场景开始”时捕获 vars 快照
- 在 Runtime 处理 `scene` action 的路径上（脚本进入场景必经 `dispatch('scene', sceneName)`），做两件事：
  - 清空 `choiceTrail`（确保只记录当前场景）
  - 记录 `sceneEntryVarsSnapshot = deepClone(state.vars)`
- 该快照随后的存档都会携带，作为该场景重放的初始 vars。

### 3) 存档写入 entryVars + choiceTrail
- 扩展 SaveData：增加 `entryVars` 字段（或 `entry: { vars }` 结构），以及启用 `choices: choiceTrail` 写入。
- 同时在 [persistProgress](file:///d:/Projcets/KosuzuEngine/src/engine/core/Runtime.ts#L740-L752) 恢复写入 `choices`（自动恢复也需要确定性）。

### 4) 修复 full/fast 的重放策略
- 将 `replayToFrame` 拆成两种策略（或增加 mode 参数）：
  - full：不跳过非 say action；say 在 `frame<target` 自动继续。
  - fast：到目标帧前禁止 `emit/persist/暂停`，但 reducer 仍推进（保证最终状态正确）。

### 5) 重放的初始状态用 entryVars 构建
- full/fast 开始重放时，不用“读档快照 state”（那是目标帧的结果态），而是：
  - 从 `initialEngineState` 出发
  - 注入 `vars = entryVars`
  - 然后 `dispatch('scene', sceneName)`，再执行 sceneFn 并重放到目标帧

### 6) 修复 DemoVN 的 full 分支（保证真的执行脚本）
- 调整 [DemoVN.startSceneFromFrame](file:///d:/Projcets/KosuzuEngine/src/pages/DemoVN.vue#L143-L189) 的早退逻辑：full 模式不再 hydrate 后 return，而是进入上述“从入口重放”的统一流程。

## 验证标准
- 场景脚本包含：`setVar` 决定循环次数 + `choice` 分支 + 多个 `say`。
- full 恢复：视觉/音频按脚本依次变化，自动快进停在目标帧。
- fast 恢复：目标帧前视觉/音频/持久化不变化，到目标帧一次性出现正确状态并停下。
- 同一存档多次恢复：分支与目标帧一致（由 choiceTrail + entryVars 保证）。